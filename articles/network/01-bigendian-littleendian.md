# 大端模式和小端模式

*   大端模式（big-endian）

    数据的**高字节**保存在内存的**低地址**中，而数据的**低字节**保存在内存的**高地址**中。

*   小端模式（little-endian）

    数据的**低字节**保存在内存的**低地址**中，而数据的**高字节**保存在内存的**高地址**中。


## 数据

例如 16 bit 的数字 5000，占两个字节，16 进制表示为 0x1388。数据的高字节为 0x13，数据的低字节为 0x88。

## 内存

在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为 8bit。

例如相邻的两个地址：0xc000018138（低地址） 0xc000018139（高地址）

## 示例

如果按大端模式保存则为：

| 地址 | 0xc000018138 | 0xc000018139 |
|------|--------------|--------------|
| 数据 | 0x13         | 0x88         |

如果按小端模式保存则为：

| 地址 | 0xc000018138 | 0xc000018139 |
|------|--------------|--------------|
| 数据 | 0x88         | 0x13         |

## Go 代码示例

```go
package main

import (
	"encoding/binary"
	"fmt"
)

func main() {
	var a uint16 = 5000

	// 大端模式
	be := make([]byte, 2)
	binary.BigEndian.PutUint16(be, a)
	fmt.Printf("%#x %p %p\n", be, &be[0], &be[1]) // 0x1388 0xc000018138 0xc000018139

	// 小端模式
	le := make([]byte, 2)
	binary.LittleEndian.PutUint16(le, a)
	fmt.Printf("%#x %p %p\n", le, &le[0], &le[1]) // 0x8813 0xc000018158 0xc000018159

	// 判断是大端模式还是小端模式
	b := uint8(a)
	if 0x13 == b {
		fmt.Println("big-endian")
	} else if 0x88 == b {
		fmt.Println("little-endian")
	} else {
		fmt.Println("ohh! shit happen!")
	}
}
```

## 现阶段状况

> 目前 Intel 的 80x86 系列芯片是唯一还在坚持使用小端的芯片，ARM 芯片默认采用小端，但可以切换为大端；
> 而 MIPS 等芯片要么采用全部大端的方式储存，要么提供选项支持大端——可以在大小端之间切换。
>
> 另外，对于大小端的处理也和编译器的实现有关，在 C 语言中，默认是小端（但在一些对于单片机的实现中却是基于大端，比如 Keil 51C），
> Java 是平台无关的，默认是大端。
>
> 在网络上传输数据普遍采用的都是大端。

## 参考资料

*   [大小端模式 - 百度百科](https://baike.baidu.com/item/大小端模式)
